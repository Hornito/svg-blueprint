/**
 * Modules in this bundle
 * @license
 *
 * svg-blueprint:
 *   license: MIT (http://opensource.org/licenses/MIT)
 *   author: SÃ©bastien Mischler <sebastien@onlfait.ch>
 *   homepage: https://github.com/onlfait/svg-blueprint
 *   version: 0.2.0
 *
 * This header is generated by licensify (https://github.com/twada/licensify)
 */
require=(function(){function r(e,n,t){function o(i,f){if(!n[i]){if(!e[i]){var c="function"==typeof require&&require;if(!f&&c)return c(i,!0);if(u)return u(i,!0);var a=new Error("Cannot find module '"+i+"'");throw a.code="MODULE_NOT_FOUND",a}var p=n[i]={exports:{}};e[i][0].call(p.exports,function(r){var n=e[i][1][r];return o(n||r)},p,p.exports,r,e,n,t)}return n[i].exports}for(var u="function"==typeof require&&require,i=0;i<t.length;i++)o(t[i]);return o}return r})()({1:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _settings = _interopRequireDefault(require("./settings"));

var _templates = _interopRequireDefault(require("./templates"));

var _point = _interopRequireDefault(require("./point"));

var _pointers = _interopRequireDefault(require("./pointers"));

var _dom = require("./dom");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(source, true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(source).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

// Unique ID; Incremented each time a Blueprint class is instanciated.
var uid = 0; // Firefox detection

var isFirefox = !!navigator.userAgent.match(/firefox/i);
/**
 * Get and check parent Element from settings object.
 *
 * @param  {object}  params
 * @param  {Element} params.parentElement
 * @param  {string}  params.parentSelector
 * @return {Element}
 * @throws {Error}
 */

function getParent(_ref) {
  var parentElement = _ref.parentElement,
      parentSelector = _ref.parentSelector;
  var parent = null;

  if (parentElement !== null) {
    if (!(parentElement instanceof Element)) {
      throw new Error("Option { parentElement } must be of type Element.");
    }

    return parentElement;
  }

  parent = document.querySelector(parentSelector);

  if (!parent) {
    throw new Error("No parent found with the selector [ ".concat(parentSelector, " ]"));
  }

  return parent;
}
/**
 * Blueprint class.
 */


var Blueprint =
/*#__PURE__*/
function () {
  /**
   * Blueprint constructor.
   *
   * @param {object} [options={}]
   */
  function Blueprint() {
    var _this = this;

    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

    _classCallCheck(this, Blueprint);

    /** @type {int} Unique ID. */
    this.uid = uid++;
    /** @type {object} Local settings. */

    this.settings = _objectSpread({}, _settings["default"], {}, options);
    /** @type {Element} Parent DOM Element. */

    this.parent = getParent(this.settings);
    /** @type {object} Collection of DOM Elements. */

    this.elements = _templates["default"].blueprint(_objectSpread({}, this.settings, {
      uid: uid
    }));
    /** @type {Point} Current position. */

    this.position = new _point["default"](0, 0);
    /** @type {Point} Cursor position. */

    this.cursor = new _point["default"](0, 0);
    /** @type {float} Current scale factor. */

    this.scale = 1;
    /** @type {int} Grid size. */

    this.gridSize = 100;
    /** @type {Pointers} Pointers instance. */

    this.pointers = new _pointers["default"](this.parent); // append the blueprint element to parent element

    this.parent.appendChild(this.elements.blueprint); // tap

    this.pointers.on("tap.end", function (event) {
      if (event.data.tapCount === 2) {
        _this.fit();
      }
    }); // pan

    var panId = null;
    this.pointers.on("pan.start", function (event) {
      if (panId !== null) return;
      panId = event.data.id;

      _this.pan(event.data.panOffsets);

      _this.updateCursorPosition({
        position: event.data.position,
        show: true
      });
    });
    this.pointers.on("pan.move", function (event) {
      if (panId !== event.data.id) return;

      _this.pan(event.data.movement);

      _this.updateCursorPosition({
        position: event.data.position,
        show: true
      });
    });
    this.pointers.on("pan.end", function (event) {
      if (panId !== event.data.id) return;

      _this.hide("cursor");

      panId = null;
    }); // pinch

    var pinchRatio = null;
    var pinchMidpoint = null;
    this.pointers.on("pinch.start", function (event) {
      panId = null; // end pan...

      pinchRatio = 1; //event.data.pinchRatio;

      pinchMidpoint = event.data.pinchMidpoint;

      _this.updateCursorPosition({
        position: pinchMidpoint,
        show: true
      });
    });
    this.pointers.on("pinch.move", function (event) {
      panId = null; // end pan...

      _this.zoom({
        ratio: _this.scale + event.data.pinchRatio - pinchRatio,
        target: pinchMidpoint
      });

      pinchRatio = event.data.pinchRatio;

      _this.updateCursorPosition({
        position: pinchMidpoint,
        show: true
      });
    });
    this.pointers.on("pinch.end", function () {
      _this.hide("cursor");
    }); // mouse wheel

    this.pointers.on("wheel.start", function (event) {
      _this.updateCursorPosition({
        position: event.data.position,
        show: true
      });
    });
    this.pointers.on("wheel.move", function (event) {
      _this.zoom({
        delta: event.data.delta,
        target: event.data.position
      });

      _this.updateCursorPosition({
        position: event.data.position,
        show: true
      });
    });
    this.pointers.on("wheel.end", function () {
      _this.hide("cursor");
    });
  }
  /**
   * Show/Hide an element.
   *
   * - show("axis");
   * - show("axis grid");
   * - show("axis grid", false);
   * - show(["axis", "grid"], true);
   *
   * @param {string|array} what axis, grid, etc...
   * @param {bool}         [display=true]
   */


  _createClass(Blueprint, [{
    key: "show",
    value: function show(what) {
      var _this2 = this;

      var display = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;

      if (!Array.isArray(what)) {
        what = what.split(/[\s,]+/);
      }

      what.forEach(function (key) {
        if (_this2.elements[key]) {
          (0, _dom.setStyle)(_this2.elements[key], "display", display ? null : "none");
        }
      });
    }
    /**
     * Hide/Show an element.
     *
     * - hide("axis");
     * - hide("axis grid");
     * - hide("axis grid", false);
     * - hide(["axis", "grid"], true);
     *
     * @param {string} what axis, grid, etc...
     * @param {bool}   [hide=true]
     */

  }, {
    key: "hide",
    value: function hide(what) {
      var _hide = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;

      this.show(what, !_hide);
    }
    /**
     * Redraw the workspace.
     */

  }, {
    key: "redraw",
    value: function redraw() {
      // translate axis
      (0, _dom.setTransform)(this.elements.axisX, "translate", [0, -this.position.y]);
      (0, _dom.setTransform)(this.elements.axisY, "translate", [-this.position.x, 0]); // translate cursor

      (0, _dom.setTransform)(this.elements.cursorX, "translate", [0, this.cursor.y]);
      (0, _dom.setTransform)(this.elements.cursorY, "translate", [this.cursor.x, 0]); // translate grid

      (0, _dom.setAttribute)(this.elements.gridPattern, "patternTransform", "translate(".concat(-this.position.x, ", ").concat(-this.position.y, ")")); // scale grid

      var gridSize = {
        width: this.gridSize,
        height: this.gridSize
      };
      var gridPath = "M ".concat(this.gridSize, " 0 L 0 0 0 ").concat(this.gridSize);
      (0, _dom.setAttribute)(this.elements.gridFill10, gridSize);
      (0, _dom.setAttribute)(this.elements.gridFill100, gridSize);
      (0, _dom.setAttribute)(this.elements.gridPattern, gridSize);
      (0, _dom.setAttribute)(this.elements.gridPattern10, "d", gridPath);
      (0, _dom.setAttribute)(this.elements.gridPattern100, "d", gridPath); // scale stroke width

      if (this.settings.nonScalingStroke === true) {
        var strokeWidth = this.settings.strokeWidth / this.scale;
        (0, _dom.setStyle)(this.elements.workspace, "stroke-width", strokeWidth);
      } // translate workspace


      (0, _dom.setAttribute)(this.elements.workspace, "viewBox", [this.position.x / this.scale, this.position.y / this.scale, 1 / this.scale, 1 / this.scale]); // Force redraw to fix blurry lines

      if (isFirefox) {
        var clone = this.elements.workspace.cloneNode(true);
        this.elements.canvas.replaceChild(clone, this.elements.workspace);
        this.elements.bbox = clone.querySelector('[data-key="bbox"]');
        this.elements.workspace = clone;
      }
    }
    /**
     * Update the cursor position.
     *
     * @param {object} [options={}]
     * @param {Point}  options.position
     * @param {bool}   [options.show=false]
     */

  }, {
    key: "updateCursorPosition",
    value: function updateCursorPosition() {
      var _ref2 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
          position = _ref2.position,
          _ref2$show = _ref2.show,
          show = _ref2$show === void 0 ? false : _ref2$show;

      this.cursor = new _point["default"](position);
      this.show("cursor", show);
      this.redraw();
    }
    /**
     * Move the workspace at position.
     *
     * @param {Point} point
     */

  }, {
    key: "move",
    value: function move(point) {
      this.position = new _point["default"](point);
      this.redraw();
    }
    /**
     * Move the workspace by offsets.
     *
     * @param {Point} point
     */

  }, {
    key: "pan",
    value: function pan(point) {
      this.position = this.position.sub(point);
      this.redraw();
    }
    /**
     * Return the center point of the workspace.
     *
     * @return {Point}
     */

  }, {
    key: "getWorkspaceCenter",
    value: function getWorkspaceCenter() {
      return new _point["default"](this.elements.blueprint.offsetWidth / 2, this.elements.blueprint.offsetHeight / 2);
    }
    /**
     * Zoom the workspace.
     *
     * @param {float|object} [scale={}]          Scale ratio or scale options.
     * @param {float}        [scale.ratio=1]     New scale ratio, used by center view etc...
     * @param {float}        [scale.delta=null]  Amount of scale to add, based on zoomFactor setting.
     * @param {object}       [scale.target=null] Zoom target point, by default center of workspace.
     */

  }, {
    key: "zoom",
    value: function zoom() {
      var scale = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      // old scale
      var oldScale = this.scale; // old way...

      if (_typeof(scale) !== "object") {
        scale = {
          ratio: scale
        };
      } // merge defaults settings


      scale = _objectSpread({
        ratio: 1,
        delta: null,
        target: null
      }, scale); // scale by ratio/delta ?

      if (scale.delta !== null) {
        scale.delta *= this.settings.zoomDirection;
        this.scale += scale.delta * this.settings.zoomFactor * this.scale;
      } else {
        this.scale = scale.ratio;
      } // zoom limit


      if (this.scale < this.settings.zoomLimit.min) {
        this.scale = this.settings.zoomLimit.min;
      } else if (this.scale > this.settings.zoomLimit.max) {
        this.scale = this.settings.zoomLimit.max;
      } // (calculate) new grid size


      var gridSize = this.scale.toString().replace(".", "").replace(/e.*/, "").replace(/^0+/, "").replace(/^([1-9])/, "$1.");
      this.gridSize = parseFloat(gridSize) * 100; // target point, default to center of workspace

      scale.target = scale.target ? new _point["default"](scale.target) : this.getWorkspaceCenter(); // mouse coordinates at current scale

      var coords = scale.target.div(oldScale).add(this.position.div(oldScale)); // new position

      this.position = new _point["default"](coords.x * this.scale - scale.target.x, coords.y * this.scale - scale.target.y);
      this.redraw();
    }
    /**
     * Center the view at [0, 0].
     */

  }, {
    key: "center",
    value: function center() {
      this.move(this.getWorkspaceCenter().neg());
    }
    /**
     * Fit workspace to view.
     */

  }, {
    key: "fit",
    value: function fit() {
      var workspace = this.elements.bbox.getBoundingClientRect();
      var width = workspace.width / this.scale;
      var height = workspace.height / this.scale; // no contents...

      if (!width || !height) {
        this.center();
        return;
      } // zoom to fit the view minus the padding


      var padding = this.settings.fitPadding * 2;
      var scaleX = (this.elements.blueprint.offsetWidth - padding) / width;
      var scaleY = (this.elements.blueprint.offsetHeight - padding) / height;
      var scale = Math.min(scaleX, scaleY);
      this.zoom(scale); // move the workspace at center of the view

      var blueprint = this.elements.blueprint.getBoundingClientRect();
      workspace = this.elements.bbox.getBoundingClientRect();
      width = (blueprint.width - workspace.width) / 2;
      height = (blueprint.height - workspace.height) / 2;
      this.pan({
        x: -workspace.left + blueprint.left + width,
        y: -workspace.top + blueprint.top + height
      });
    }
    /**
     * Create an SVG element with default properties.
     *
     * - remove "stroke-width" attribute
     * - remove "stroke-width, stroke, fill" css properties
     * - set default "stroke" and "fill" attributes from settings
     * - "stroke-width, stroke, fill" can be overwritten by attribute parameter
     *
     * @param {string} name
     * @param {object} [attributes={}]
     *
     * @return {SVGElement}
     */

  }, {
    key: "createElement",
    value: function createElement(name) {
      var attributes = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      return (0, _dom.createSVGElement)(name, _objectSpread({
        "stroke-width": null,
        stroke: this.settings.stroke,
        fill: this.settings.fill,
        style: {
          "stroke-width": null,
          stroke: null,
          fill: null
        }
      }, attributes));
    }
    /**
     * Create and append to the workspace an SVG element with default properties.
     *
     * @param {string} name
     * @param {object} [attributes={}]
     *
     * @return {SVGElement}
     */

  }, {
    key: "append",
    value: function append(name) {
      var attributes = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      var element = this.createElement(name, attributes);
      this.elements.bbox.appendChild(element);
      return element;
    }
  }]);

  return Blueprint;
}();

var _default = Blueprint;
exports["default"] = _default;

},{"./dom":4,"./point":5,"./pointers":6,"./settings":7,"./templates":10}],2:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

/**
 * Point class.
 */
var Point =
/*#__PURE__*/
function () {
  /**
   * Point class constructor.
   *
   * - new Point()                // { x: 0 , y: 0  }
   * - new Point([])              // { x: 0 , y: 0  }
   * - new Point(42)              // { x: 42, y: 0  }
   * - new Point([ 42 ])          // { x: 42, y: 0  }
   * - new Point(42, 10)          // { x: 42, y: 10 }
   * - new Point([ 42, 10 ])      // { x: 42, y: 10 }
   * - new Point({ x: 42, y:10 }) // { x: 42, y: 10 }
   *
   * @param {float|array|Point} [x=0]
   * @param {float}             [y=0]
   */
  function Point() {
    var x = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
    var y = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;

    _classCallCheck(this, Point);

    // input format
    if (Array.isArray(x)) {
      y = x[1] || 0;
      x = x[0] || 0;
    } else if (x.x !== undefined) {
      y = x.y || 0;
      x = x.x || 0;
    }
    /** @type {float} X value. */


    this.x = parseFloat(x);
    /** @type {float} Y value. */

    this.y = parseFloat(y);
  }
  /**
   * Add point and return new Point.
   *
   * @param  {float|array|Point} point
   * @return {Point}
   */


  _createClass(Point, [{
    key: "add",
    value: function add(point) {
      var p1 = new Point(point);
      return new Point(this.x + p1.x, this.y + p1.y);
    }
    /**
     * Substract point and return new Point.
     *
     * @param  {float|array|Point} point
     * @return {Point}
     */

  }, {
    key: "sub",
    value: function sub(point) {
      var p1 = new Point(point);
      return new Point(this.x - p1.x, this.y - p1.y);
    }
    /**
     * Multiply point and return new Point.
     *
     * @param  {float|array|Point} point
     * @return {Point}
     */

  }, {
    key: "mult",
    value: function mult(point) {
      var p1 = new Point(point, point);
      return new Point(this.x * p1.x, this.y * p1.y);
    }
    /**
     * Divide point and return new Point.
     *
     * @param  {float|array|Point} point
     * @return {Point}
     */

  }, {
    key: "div",
    value: function div(point) {
      var p1 = new Point(point, point);
      return new Point(this.x / p1.x, this.y / p1.y);
    }
    /**
     * Return negative point.
     *
     * @return {Point}
     */

  }, {
    key: "neg",
    value: function neg() {
      return new Point(-this.x, -this.y);
    }
    /**
     * Return the distance betwen the two points.
     *
     * @param  {float|array|Point} point
     * @return {float}
     */

  }, {
    key: "distance",
    value: function distance(point) {
      var diff = this.sub(point);
      var mult = diff.mult(diff);
      return Math.sqrt(mult.x + mult.y);
    }
    /**
     * Return vector midpoint.
     *
     * @param  {float|array|Point} point
     * @return {float}
     */

  }, {
    key: "midpoint",
    value: function midpoint(point) {
      return this.add(new Point(point).sub(this).mult(0.5));
    }
    /**
     * Return the values as array.
     *
     * @return {array}
     */

  }, {
    key: "toArray",
    value: function toArray() {
      return [this.x, this.y];
    }
    /**
     * Return a clone.
     *
     * @return {Point}
     */

  }, {
    key: "clone",
    value: function clone() {
      return new Point(this.x, this.y);
    }
  }]);

  return Point;
}();

var _default = Point;
exports["default"] = _default;

},{}],3:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _Point = _interopRequireDefault(require("./Point"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

/**
 * Pointer class.
 */
var Pointer =
/*#__PURE__*/
function () {
  /**
   * Pointer class constructor.
   */
  function Pointer(pointerEvent) {
    _classCallCheck(this, Pointer);

    this.event = pointerEvent;
    this.id = pointerEvent.pointerId;
    this.position = new _Point["default"]();
    this.movement = new _Point["default"]();
    this.distance = 0;
    this.down = false;
    this.downTime = 0;
    this.upTime = 0;
    this.tapCount = 0;
    this.tapDuration = 0;
    this.panning = false;
    this.panDistance = 0;
    this.panStartPosition = 0;
    this.panOffsets = new _Point["default"]();
    this.pinch = null;
    this.pinchRatio = 1;
    this.pinchDistance = 0;
    this.pinchMidpoint = 0;
    this.pinchOffset = 0;
  }
  /**
   * Clone and return the new pointer.
   *
   * @return {Pointer}
   */


  _createClass(Pointer, [{
    key: "clone",
    value: function clone() {
      var clone = {};
      var keys = Object.keys(this);

      for (var _i = 0, _keys = keys; _i < _keys.length; _i++) {
        var key = _keys[_i];
        var value = this[key];

        if (value && value instanceof _Point["default"]) {
          value = value.clone();
        }

        clone[key] = value;
      }

      return clone;
    }
  }]);

  return Pointer;
}();

var _default = Pointer;
exports["default"] = _default;

},{"./Point":2}],4:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.setStyle = setStyle;
exports.setAttribute = setAttribute;
exports.setTransform = setTransform;
exports.fromString = fromString;
exports.createElement = createElement;
exports.createSVGElement = createSVGElement;
exports.addPassiveEventListener = addPassiveEventListener;
exports.addEvent = addEvent;
exports.xmlns = void 0;

/**
 * XML namespace.
 *
 * @type {string}
 */
var xmlns = "http://www.w3.org/2000/svg";
/**
 * Support passive event listener?
 *
 * @type {bool}
 */

exports.xmlns = xmlns;
var supportsPassiveEventListener = false;

try {
  var opts = Object.defineProperty({}, "passive", {
    get: function get() {
      return supportsPassiveEventListener = true;
    }
  });
  window.addEventListener("testPassive", null, opts);
  window.removeEventListener("testPassive", null, opts);
} catch (e) {}
/* test fail... */

/**
 * Add passive event listener.
 *
 * @param {Element}      element
 * @param {array|string} name
 * @param {function}     [callback=null]
 */


function addPassiveEventListener(element, name, callback) {
  var capture = supportsPassiveEventListener ? {
    passive: true
  } : false;
  var names = name;

  if (typeof names === "string") {
    names = names.trim().split(/[\s,]+/);
  }

  names.forEach(function (name) {
    if (callback === null) {
      element.removeEventListener(name, callback, capture);
    } else {
      element.addEventListener(name, callback, capture);
    }
  });
}
/**
 * Add (passive) event(s) listener.
 *
 * @param {Element}  element
 * @param {string}   name
 * @param {function} [callback=null]
 */


function addEvent(element, name) {
  var callback = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;

  if (typeof name === "string") {
    addPassiveEventListener(element, name, callback);
    return;
  }

  var keys = Object.keys(name);

  for (var _i = 0, _keys = keys; _i < _keys.length; _i++) {
    var key = _keys[_i];
    addPassiveEventListener(element, key, name[key]);
  }
}
/**
 * Set style(s).
 *
 * Setting a NULL value remove the property.
 *
 * @param {Element}       element
 * @param {string|object} name
 * @param {null|mixed}    [value=null]
 */


function setStyle(element, name) {
  var value = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;

  if (typeof name === "string") {
    if (value === null) {
      element.style.removeProperty(name);
    } else {
      element.style.setProperty(name, value);
    }

    return;
  }

  var keys = Object.keys(name);

  for (var _i2 = 0, _keys2 = keys; _i2 < _keys2.length; _i2++) {
    var key = _keys2[_i2];
    setStyle(element, key, name[key]);
  }
}
/**
 * Set transform(s).
 *
 * - setTransform(element);                // remove all
 * - setTransform(element, null);          // remove all
 * - setTransform(element, 'scale');       // remove "scale(x)" in transform attribute
 * - setTransform(element, 'scale', null); // remove "scale(x)" in transform attribute
 * - setTransform(element, 'scale', 10);   // set "scale(10)" in transform attribute
 *
 * @param {Element}            element
 * @param {null|string|object} type
 * @param {null|mixed}         [value=null]
 */


function setTransform(element) {
  var type = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
  var value = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;

  // remove transform attribute
  if (type === null) {
    setAttribute(element, "transform", null);
    return;
  } // get current value


  var transform = element.getAttribute("transform") || ""; // ...

  var types = {};

  if (typeof type === "string") {
    types[type] = value;
  } else {
    types = type;
  }

  var keys = Object.keys(types);

  for (var _i3 = 0, _keys3 = keys; _i3 < _keys3.length; _i3++) {
    var key = _keys3[_i3];
    var _value = types[key]; // remove transform type

    transform = transform.replace(new RegExp("".concat(key, "\\([^)]+\\)"), "g"), "");

    if (_value === null) {
      continue;
    } // add new value


    if (Array.isArray(_value)) {
      transform += "".concat(key, "(").concat(_value.join(" "), ") ");
    } else {
      transform += "".concat(key, "(").concat(_value, ") ");
    }
  } // cleanup


  transform = transform.replace(/\s+/, " ").trim(); // set new transform

  setAttribute(element, "transform", transform);
}
/**
 * Set attribute(s).
 *
 * - Setting a NULL value remove the attribute.
 * - If the name parameter is "style", setStyle(element, value) is called.
 * - If the name parameter is "event", addEvent(element, value) is called.
 * - If the name parameter is "transform", setTransform(element, value) is called.
 *
 * @param {Element}       element
 * @param {string|object} name
 * @param {null|mixed}    [value=null]
 */


function setAttribute(element, name) {
  var value = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;

  if (typeof name === "string") {
    if (value === null) {
      element.removeAttribute(name);
    } else {
      element.setAttribute(name, value);
    }

    return;
  }

  var keys = Object.keys(name);

  for (var _i4 = 0, _keys4 = keys; _i4 < _keys4.length; _i4++) {
    var key = _keys4[_i4];

    if (key === "style") {
      setStyle(element, name[key]);
    } else if (key === "event") {
      addEvent(element, name[key]);
    } else if (key === "transform") {
      setTransform(element, name[key]);
    } else {
      setAttribute(element, key, name[key]);
    }
  }
}
/**
 * Create en return a DOM Element from a string.
 *
 * @param {string} string
 * @param {string} [mimeType="application/xml"]
 *
 * @return {Element}
 */


function fromString(string) {
  var mimeType = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : "application/xml";
  return new DOMParser().parseFromString(string, mimeType);
}
/**
 * Create en return a DOM Element.
 *
 * @param {string}      string
 * @param {null|object} [attributes=null]
 *
 * @return {Element}
 */


function createElement(name) {
  var attributes = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
  var element = document.createElement(name);

  if (attributes !== null) {
    setAttribute(element, attributes);
  }

  return element;
}
/**
 * Create en return a SVG Element.
 *
 * @param {string}      string
 * @param {null|object} [attributes=null]
 *
 * @return {SVGElement}
 */


function createSVGElement(name) {
  var attributes = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
  var element = null;

  if (name.charAt(0) === "<") {
    var doc = fromString("<svg xmlns=\"".concat(xmlns, "\">").concat(name, "</svg>"));
    element = doc.documentElement.firstChild;
  } else {
    element = document.createElementNS(xmlns, name);
  }

  if (attributes !== null) {
    setAttribute(element, attributes);
  }

  return element;
}

},{}],5:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

/**
 * Point class.
 */
var Point =
/*#__PURE__*/
function () {
  /**
   * Point class constructor.
   *
   * - new Point()                // { x: 0 , y: 0  }
   * - new Point([])              // { x: 0 , y: 0  }
   * - new Point(42)              // { x: 42, y: 0  }
   * - new Point([ 42 ])          // { x: 42, y: 0  }
   * - new Point(42, 10)          // { x: 42, y: 10 }
   * - new Point([ 42, 10 ])      // { x: 42, y: 10 }
   * - new Point({ x: 42, y:10 }) // { x: 42, y: 10 }
   *
   * @param {float|array|Point} [x=0]
   * @param {float}             [y=0]
   */
  function Point() {
    var x = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
    var y = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;

    _classCallCheck(this, Point);

    // input format
    if (Array.isArray(x)) {
      y = x[1] || 0;
      x = x[0] || 0;
    } else if (x.x !== undefined) {
      y = x.y || 0;
      x = x.x || 0;
    }
    /** @type {float} X value. */


    this.x = parseFloat(x);
    /** @type {float} Y value. */

    this.y = parseFloat(y);
  }
  /**
   * Add point and return new Point.
   *
   * @param  {float|array|Point} point
   * @return {Point}
   */


  _createClass(Point, [{
    key: "add",
    value: function add(point) {
      var p1 = new Point(point);
      return new Point(this.x + p1.x, this.y + p1.y);
    }
    /**
     * Substract point and return new Point.
     *
     * @param  {float|array|Point} point
     * @return {Point}
     */

  }, {
    key: "sub",
    value: function sub(point) {
      var p1 = new Point(point);
      return new Point(this.x - p1.x, this.y - p1.y);
    }
    /**
     * Multiply point and return new Point.
     *
     * @param  {float|array|Point} point
     * @return {Point}
     */

  }, {
    key: "mult",
    value: function mult(point) {
      var p1 = new Point(point, point);
      return new Point(this.x * p1.x, this.y * p1.y);
    }
    /**
     * Divide point and return new Point.
     *
     * @param  {float|array|Point} point
     * @return {Point}
     */

  }, {
    key: "div",
    value: function div(point) {
      var p1 = new Point(point, point);
      return new Point(this.x / p1.x, this.y / p1.y);
    }
    /**
     * Return negative point.
     *
     * @return {Point}
     */

  }, {
    key: "neg",
    value: function neg() {
      return new Point(-this.x, -this.y);
    }
    /**
     * Return the distance betwen the two points.
     *
     * @param  {float|array|Point} point
     * @return {float}
     */

  }, {
    key: "distance",
    value: function distance(point) {
      var diff = this.sub(point);
      var mult = diff.mult(diff);
      return Math.sqrt(mult.x + mult.y);
    }
    /**
     * Return vector midpoint.
     *
     * @param  {float|array|Point} point
     * @return {float}
     */

  }, {
    key: "midpoint",
    value: function midpoint(point) {
      return this.add(new Point(point).sub(this).mult(0.5));
    }
    /**
     * Return the values as array.
     *
     * @return {array}
     */

  }, {
    key: "toArray",
    value: function toArray() {
      return [this.x, this.y];
    }
    /**
     * Return a clone.
     *
     * @return {Point}
     */

  }, {
    key: "clone",
    value: function clone() {
      return new Point(this.x, this.y);
    }
  }]);

  return Point;
}();

var _default = Point;
exports["default"] = _default;

},{}],6:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _dom = require("./dom");

var _Pointer = _interopRequireDefault(require("./Pointer"));

var _Point = _interopRequireDefault(require("./Point"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(source, true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(source).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

/**
 * Defaults settings.
 *
 * @type {object}
 */
var settings = {
  panThreshold: 10,
  // px
  tapThreshold: 200,
  // ms
  tapTimeout: 500 // ms

};
/**
 * Pointers event types list.
 *
 * @type {array}
 */

var eventTypes = ["pointerover", "pointerenter", "pointerdown", "pointermove", "pointerup", "pointercancel", "pointerout", "pointerleave", "gotpointercapture", "lostpointercapture"];
/**
 * Pointers class.
 */

var Pointers =
/*#__PURE__*/
function () {
  /**
   * Pointers class constructor.
   *
   * @param {Element} element
   */
  function Pointers(target) {
    var _this = this;

    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

    _classCallCheck(this, Pointers);

    /** @type {Element} Target element. */
    this.target = target;
    /** @type {object} Current settings. */

    this.settings = _objectSpread({}, settings, {}, options);
    /** @type {array} Callbacks list. */

    this.callbacks = [];
    /** @type {Map} Pointerss collection. */

    this.pointers = new Map();
    /** @type {int} Tap counter. */

    this.tapCount = 0;
    /** @type {int} Tap timeout ID. */

    this.tapTimeout = null;
    /** @type {int} Wheel timeout ID. */

    this.wheelTimeout = null; // disable browser touch events on the target element

    (0, _dom.setStyle)(target, "touch-action", "none"); // track all pointers events

    (0, _dom.addEvent)(target, eventTypes.join(","), function (pointerEvent) {
      _this.trackPointer(pointerEvent);
    }); // remove pointer on leave/cancel/lostcapture

    (0, _dom.addEvent)(target, "pointerleave pointercancel lostpointercapture", function (pointerEvent) {
      _this.deletePointer(pointerEvent.pointerId);
    }); // mouse wheel (not a pointer event, add for convenience)

    (0, _dom.addEvent)(target, "wheel", function (mouseEvent) {
      _this.onMouseWheel(mouseEvent);
    });
  }
  /**
   * Has pointer id.
   *
   * @param {int} id
   *
   * @return {Boolean}
   */


  _createClass(Pointers, [{
    key: "hasPointer",
    value: function hasPointer(id) {
      return this.pointers.has(id);
    }
    /**
     * Get pointer by id.
     *
     * @param {int} id
     *
     * @return {null|Pointer}
     */

  }, {
    key: "getPointer",
    value: function getPointer(id) {
      return this.pointers.get(id);
    }
    /**
     * Set new pointer.
     *
     * @param {Pointer} pointer
     */

  }, {
    key: "setPointer",
    value: function setPointer(pointer) {
      this.pointers.set(pointer.id, pointer);
    }
    /**
     * Delete pointer by id.
     *
     * @param {int} id
     */

  }, {
    key: "deletePointer",
    value: function deletePointer(id) {
      if (this.pointers.has(id)) {
        this.pointers["delete"](id);
      }
    }
    /**
     * Return the relative position of the pointer from the target element.
     *
     * @param {PointerEvent} pointerEvent
     *
     * @return {Point}
     */

  }, {
    key: "getPosition",
    value: function getPosition(pointerEvent) {
      var offsets = this.target.getBoundingClientRect();
      return new _Point["default"](pointerEvent.pageX - offsets.left, pointerEvent.pageY - offsets.top);
    }
    /**
     * Tap recognizer.
     *
     * @param {string}  eventType
     * @param {Pointer} pointer
     */

  }, {
    key: "tapRecognizer",
    value: function tapRecognizer(eventType, pointer) {
      var _this2 = this;

      if (eventType !== "up") {
        return;
      } // calculate duration between up and down event


      var tapDuration = pointer.upTime - pointer.downTime;

      if (tapDuration > this.settings.tapThreshold) {
        return; // time out
      } // clear tap timeout if any


      this.tapTimeout && clearTimeout(this.tapTimeout); // increment tap counter

      pointer.tapCount = ++this.tapCount;
      pointer.tapDuration = tapDuration; // emit tap start event

      if (this.tapCount === 1) {
        this.emit("tap.start", pointer.clone());
      } // emit tap event...


      this.emit("tap", pointer.clone()); // watch for tap end event

      this.tapTimeout = setTimeout(function () {
        _this2.emit("tap.end", pointer.clone());

        _this2.tapCount = 0;
      }, this.settings.tapTimeout);
    }
    /**
     * Pan recognizer.
     *
     * @param {string}  eventType
     * @param {Pointer} pointer
     */

  }, {
    key: "panRecognizer",
    value: function panRecognizer(eventType, pointer) {
      if (eventType === "move") {
        if (pointer.panStartPosition) {
          pointer.panOffsets = pointer.position.sub(pointer.panStartPosition);
          pointer.panDistance = pointer.panStartPosition.distance(pointer.position);

          if (pointer.panning) {
            this.emit("pan.move", pointer.clone());
          } else if (pointer.panDistance > this.settings.panThreshold) {
            pointer.panning = true;
            this.emit("pan.start", pointer.clone());
          }
        }

        return;
      }

      if (eventType === "down") {
        if (!pointer.panStartPosition) {
          pointer.panStartPosition = pointer.position.clone();
        }

        return;
      }

      if (["up", "leave", "cancel", "lostcapture"].indexOf(eventType) !== -1) {
        if (pointer.panStartPosition) {
          if (pointer.panning) {
            this.emit("pan.end", pointer.clone());
          }

          pointer.panOffsets = new _Point["default"]();
          pointer.panStartPosition = 0;
          pointer.panDistance = 0;
          pointer.panning = false;
        }

        return;
      }
    }
  }, {
    key: "onPinch",
    value: function onPinch(p1, p2) {
      var pinchDistance = p1.position.distance(p2.position);
      var pinchMidpoint = p1.position.midpoint(p2.position);
      var pinchOffset = p1.pinchOffset || pinchDistance;
      var pinchRatio = pinchDistance / p1.pinchOffset;
      Object.assign(p1, {
        pinchDistance: pinchDistance,
        pinchMidpoint: pinchMidpoint,
        pinchOffset: pinchOffset,
        pinchRatio: pinchRatio
      });
      Object.assign(p2, {
        pinchDistance: pinchDistance,
        pinchMidpoint: pinchMidpoint,
        pinchOffset: pinchOffset,
        pinchRatio: pinchRatio
      });
    }
    /**
     * Pinch recognizer.
     *
     * @param {string}  eventType
     * @param {Pointer} pointer
     */

  }, {
    key: "pinchRecognizer",
    value: function pinchRecognizer(eventType, pointer) {
      if (eventType === "move") {
        if (pointer.pinch) {
          this.onPinch(pointer, pointer.pinch);
          this.emit("pinch.move", pointer.clone());
        }

        return;
      }

      if (eventType === "down") {
        var p1 = null;
        this.pointers.forEach(function (p) {
          if (p1 || !p.down || p.pinch || p.id === pointer.id) return;
          p1 = p;
        });

        if (p1) {
          p1.pinch = pointer;
          pointer.pinch = p1;
          this.onPinch(p1, pointer);
          this.emit("pinch.start", pointer.clone());
        }

        return;
      }

      var pinchReset = function pinchReset(point) {
        point.pinch = null;
        point.pinchRatio = 1;
        point.pinchDistance = 0;
        point.pinchMidpoint = 0;
        point.pinchOffset = 0;
      };

      if (eventType === "up") {
        if (pointer.pinch) {
          this.emit("pinch.end", pointer.clone());
          pinchReset(pointer.pinch);
          pinchReset(pointer);
        }

        return;
      }
    }
    /**
     * Track pointer event.
     *
     * @param {PointersEvent} pointerEvent
     */

  }, {
    key: "trackPointer",
    value: function trackPointer(pointerEvent) {
      // event type
      var eventType = pointerEvent.type.replace("pointer", ""); // get the pointer

      var pointer = this.getPointer(pointerEvent.pointerId); // get current position

      var position = this.getPosition(pointerEvent); // add new pointer if not already set

      if (!pointer) {
        pointer = new _Pointer["default"](pointerEvent);
        pointer.position = position;
        this.setPointer(pointer);
      } // update pointer


      if (eventType === "move") {
        pointer.distance = pointer.position.distance(position);
        pointer.movement = position.sub(pointer.position);
        pointer.position = position;
      } else if (eventType === "down") {
        pointer.downTime = Date.now();
        pointer.down = true;
      } else if (eventType === "up") {
        pointer.upTime = Date.now();
        pointer.down = false;
      } // emit event


      this.emit(eventType, pointer.clone()); // recognizers

      this.tapRecognizer(eventType, pointer);
      this.panRecognizer(eventType, pointer);
      this.pinchRecognizer(eventType, pointer);
    }
    /**
     * On mouse wheel...
     *
     * @param {MouseEvent} mouseEvent
     */

  }, {
    key: "onMouseWheel",
    value: function onMouseWheel(mouseEvent) {
      var _this3 = this;

      var delta = mouseEvent.deltaY > 0 ? 1 : -1;
      var pointer = new _Pointer["default"](mouseEvent);
      pointer.position = this.getPosition(mouseEvent);
      pointer.delta = delta;

      if (this.wheelTimeout === null) {
        this.emit("wheel.start", pointer);
      }

      this.emit("wheel.move", pointer);
      clearTimeout(this.wheelTimeout);
      this.wheelTimeout = setTimeout(function () {
        _this3.wheelTimeout = null;

        _this3.emit("wheel.end", pointer);
      }, 120);
    }
    /**
     * Register event callback.
     *
     * @param {array|string} type
     * @param {function}     func
     */

  }, {
    key: "on",
    value: function on(type, func) {
      var _this4 = this;

      var types = type;

      if (typeof types === "string") {
        types = types.trim().split(/[\s,]+/);
      }

      types.forEach(function (type) {
        _this4.callbacks.push({
          type: type,
          func: func
        });
      });
    }
    /**
     * Emit an event.
     *
     * @param {string} type
     * @param {object} [data={}]
     */

  }, {
    key: "emit",
    value: function emit(type) {
      var data = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      this.callbacks.forEach(function (callback) {
        if (callback.type === type || callback.type === "*") {
          callback.func({
            type: type,
            data: data
          });
        }
      });
    }
  }]);

  return Pointers;
}();

var _default = Pointers;
exports["default"] = _default;

},{"./Point":2,"./Pointer":3,"./dom":4}],7:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

/**
 * Defaults settings.
 *
 * @type {object}
 */
var settings = {
  width: "400px",
  height: "300px",
  parentElement: null,
  parentSelector: "body",
  className: "svg-blueprint",
  backgroundColor: "#3177C6",
  gridColor: "#fff",
  gridOpacity: 0.3,
  cursorColor: "#0b64c4",
  cursorOpacity: 1,
  axisColor: "#f4b916",
  axisOpacity: 0.5,
  nonScalingStroke: true,
  strokeWidth: 2,
  zoomFactor: 0.05,
  zoomDirection: 1,
  zoomLimit: {
    min: 0.0001,
    max: 10000
  },
  fitPadding: 42,
  stroke: "#fff",
  fill: "none"
};
var _default = settings;
exports["default"] = _default;

},{}],8:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.format = format;
exports.toElements = toElements;
exports.template = template;
exports.templateFactory = templateFactory;
exports["default"] = void 0;

/**
 * Simple string tag replacement.
 *
 * ex.: format("Hello {{name}}", { name: "World"}) // Hello World
 *
 * @param {string} string
 * @param {object} data
 *
 * @return {string}
 */
function format(string, data) {
  return string.replace(/(\{\{([^}]+)\}\})/g, function (match, p1, p2) {
    return data[p2] || p1;
  });
}
/**
 * Get an HTML string and return a collection of DOM Element.
 *
 * Only elements with a [data-key] attribute will be returned.
 *
 * ex.: toElements('<div data-key="myElement">...</div>')
 * return: { myElement: Element }
 *
 * @param {string} string
 *
 * @return {object}
 */


function toElements(string) {
  var elements = {};
  var div = document.createElement("div");
  div.innerHTML = string.trim();
  var list = div.querySelectorAll("[data-key]");
  Array.prototype.forEach.call(list, function (item) {
    elements[item.getAttribute("data-key")] = item;
  });
  return elements;
}
/**
 * Get an HTML string and some data and return a collection of DOM Element.
 *
 * Only elements with a [data-key] attribute will be returned.
 *
 * ex.: template(
 *        '<div data-key="myElement">{{message}}</div>',
 *        { message: "Hello World"}
 *      )
 * return: { myElement: Element }
 *
 * @param {string}      string
 * @param {null|object} [data=null]
 *
 * @return {object}
 */


function template(string) {
  var data = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
  return toElements(data ? format(string, data) : string);
}
/**
 * Create and return a template function from an HTML string.
 *
 * ex.: const myTemplate = templateFactory('<div data-key="myElement">{{message}}</div>')
 *      myTemplate({ message: 'Hello World'}) // { myElement: Element }
 *
 * @param {string} string
 *
 * @return {Function}
 */


function templateFactory(string) {
  return function (data) {
    return template(string, data);
  };
}

var _default = template;
exports["default"] = _default;

},{}],9:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _template = require("../template");

var _default = (0, _template.templateFactory)("\n<div data-key=\"blueprint\" class=\"{{className}} {{className}}-{{uid}}\" style=\"width: {{width}}; height: {{height}};\">\n\n  <svg data-key=\"canvas\" class=\"{{className}}-grid\" style=\"position: relative; width: 100%; height: 100%; overflow: hidden;\" xmlns=\"http://www.w3.org/2000/svg\">\n    <defs>\n      <pattern id=\"gridPattern10\" width=\"0.1\" height=\"0.1\">\n        <path data-key=\"gridPattern10\" d=\"M 10 0 L 0 0 0 10\" fill=\"none\" stroke=\"{{gridColor}}\" stroke-width=\"0.1\" />\n      </pattern>\n      <pattern id=\"gridPattern100\" width=\"1\" height=\"1\">\n        <path data-key=\"gridPattern100\" d=\"M 100 0 L 0 0 0 100\" fill=\"none\" stroke=\"{{gridColor}}\" stroke-width=\"1\" />\n      </pattern>\n      <pattern data-key=\"gridPattern\" id=\"gridPattern\" width=\"100\" height=\"100\" patternUnits=\"userSpaceOnUse\">\n        <rect data-key=\"gridFill10\" fill=\"url(#gridPattern10)\" width=\"100\" height=\"100\" />\n        <rect data-key=\"gridFill100\" fill=\"url(#gridPattern100)\" width=\"100\" height=\"100\" opacity=\"{{gridOpacity}}\" />\n      </pattern>\n    </defs>\n    <rect data-key=\"background\" class=\"{{className}}-background\" width=\"100%\" height=\"100%\" fill=\"{{backgroundColor}}\" />\n    <rect data-key=\"grid\" class=\"{{className}}-grid\" width=\"100%\" height=\"100%\" fill=\"url(#gridPattern)\" />\n    <g data-key=\"axis\" class=\"{{className}}-axis\" style=\"opacity: {{axisOpacity}};\">\n      <line data-key=\"axisX\" x1=\"0\" y1=\"0\" x2=\"100%\" y2=\"0\" stroke=\"{{axisColor}}\" stroke-width=\"1\" transform=\"translate(0 0)\" />\n      <line data-key=\"axisY\" x1=\"0\" y1=\"0\" x2=\"0\" y2=\"100%\" stroke=\"{{axisColor}}\" stroke-width=\"1\" transform=\"translate(0 0)\" />\n    </g>\n    <g data-key=\"cursor\" class=\"{{className}}-cursor\" style=\"opacity: {{cursorOpacity}}; display: none;\">\n      <line data-key=\"cursorX\" x1=\"0\" y1=\"0\" x2=\"100%\" y2=\"0\" stroke=\"{{cursorColor}}\" stroke-width=\"1\" transform=\"translate(0 0)\" />\n      <line data-key=\"cursorY\" x1=\"0\" y1=\"0\" x2=\"0\" y2=\"100%\" stroke=\"{{cursorColor}}\" stroke-width=\"1\" transform=\"translate(0 0)\" />\n    </g>\n\n    <svg\n      data-key=\"workspace\"\n      class=\"{{className}}-workspace\"\n      width=\"1\"\n      height=\"1\"\n      viewBox=\"0 0 1 1\"\n      style=\"position: absolute; overflow: visible; fill: {{fill}}; stroke: {{stroke}}; stroke-width: {{strokeWidth}};\"\n      xmlns=\"http://www.w3.org/2000/svg\">\n\n      <g data-key=\"bbox\"></g>\n\n    </svg>\n\n  </svg>\n\n</div>\n");

exports["default"] = _default;

},{"../template":8}],10:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _blueprint = _interopRequireDefault(require("./blueprint"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

var _default = {
  blueprint: _blueprint["default"]
};
exports["default"] = _default;

},{"./blueprint":9}],"svg-blueprint.js":[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
Object.defineProperty(exports, "settings", {
  enumerable: true,
  get: function get() {
    return _settings["default"];
  }
});
Object.defineProperty(exports, "Blueprint", {
  enumerable: true,
  get: function get() {
    return _Blueprint["default"];
  }
});

var _settings = _interopRequireDefault(require("./settings"));

var _Blueprint = _interopRequireDefault(require("./Blueprint"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

},{"./Blueprint":1,"./settings":7}]},{},[]);
